## node
    - 事件驱动 异步回调
    - JavaScript 与其他线程是无法共享任何状态的。单线程的最大好处是不用像多线程那样处处在意状态的同步问题。这里没有锁死的存在，也没哟线程上下文交换所带来的性能开销

### 单线程的弱点
    - 无法利用多核CPU
    - 错误会引起整个系统退出，应用的健壮性指的考验 
    - 大量计算占用CPU导致无法继续调用异步I/O


    在浏览器中JavaScript 和 UI 共用一个线程，JavaScript 长时间执行会导致UI的渲染和响应被中断。
    在node中，长时间的CPU占用也会导致后续的异步I/O 发不出调用，已完成的异步I/O的回调函数也不会得到及时的执行

    Google 最初采用了 Gears 启动一个独立的进程 后来HTML5 定制了worker 来
    node 采用了child_process 子进程来解决大量计算的问题 

### node 的应用
    ####  I/O密集型
        - node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务

### 核心模块

    核心模块分为C/C++ 编写和JavaScript 编写两个部分。
    C/C++放在Node项目的src下面 
    JavaScript 放在Node 项目的lib目录下面

### 异步I/O

    不同I/O 类型以及应用开销

    I/O 类型            花费的CPU时钟周期

    CPU一级缓存         3
    CPU二级缓存         14
    内存                250
    硬盘                41000000
    网络                240000000

    I/O 是昂贵的，分布式I/O是更昂贵的。

    单线程串行一次执行 或者 多线程并行完成
    创建多线程开销小于并行执行
    
    `它的优秀之处并非原创,原创之处并不优秀`


    异步I/O 非阻塞I/O

    操作系统 内核对于I/O 只有两种方式：阻塞和非阻塞

    非租塞I/O 跟阻塞I/O的差别在条用之后立即返回

    操作系统对计算机进行抽象，将所有的输入和输出设备抽象为文件。内核在进行文件I/O操作的时候
    通过文件描述符进行管理，而文件描述符类似于应用程序于系统内核之间的凭证。

    非租塞I/O 调用立即返回，CPU的时间就可以处理其他事物
    但是完整的I/O并没有完成，立即返回的平不是业务层期望的数据
    为了读取完整的数据，应用程序需要重复调用I/O操作来确定是否完成 这种操作也叫做轮询。

    轮询技术的发展

    read -----> select ----> poll -----> epoll

    read 原始 ，性能最低的一种

    select 通过对文件描述符上的时间状态进行判断 （有1024长度数组的限制，最多同时检查1024个文件描述符）
        - read -> select... -> read => return
    
    poll 和select类似 采用链表的方式便面数组长度的限制，其次他能避免不需要的检查 (但是在文件多的时候，性能也是比较低)
        read -> poll... -> read => return
    
    
    epoll 该方案是Linux 下效率醉倒的I/O时间通知机制,在进行轮询的时候，如果没有检查到I/O时间，将会进行休眠，知道事件发生将他唤醒
    他是真实利用了之间通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高
    
    read -> poll -> 休眠 [操作系统处理] 事件触发 -> 消息 -> read

    轮询技术满足了非阻塞I/O 确保获取完整数据的需求，但是对于应用程序而言，他仍然只能算是一种同步，因为应用程序任然需要等待I/O完全返回
    。依然花费了很多时间来等待，等待期间，CPU要么用于遍历文件描述符状态，要么用于休眠等待事件发生。结论是他不够好。

### 理想的非阻塞异步I/O

    我们期望的完美异步I/O应该是应程序发起非阻塞调用，无须通过遍历或者时间唤醒等待方式循环，可以直接处理下一个任务，只需要在I/O完成后通过信号或者回调将数据传递给应用程序即可.

### 现实的异步I/O

    引入多线程
    
    通过让部分线程进行阻塞I/O 或者非阻塞I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O 得到的数据进行传递，这就轻松时间异步

    Node v0.9.3 自行实现了线程池来完成异步I/O。

    window 下使用 IOCP来实现异步I/O (调用异步方法，等待完成之后的通知，执行回调，用户无需考虑轮询，但他的内部其实仍然是线程池原理，不同之处在于这些线程次有系统内核接受管理)

    说Node是单线程的，仅只是JavaScript 执行在单线程中罢了，在node中，无论是*nix 还是window 平台，内部完成I/O任务的另有线程池。

### Node 的异步I/O

#### 事件循环

    Node 自身的执行模型——事件循环

    